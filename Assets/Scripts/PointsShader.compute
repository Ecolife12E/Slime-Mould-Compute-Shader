// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain
#pragma kernel Trails

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D<float4> Result;

struct Points
{
    float speed;
    float2 totalposition;
    float Angle;
};

RWStructuredBuffer<Points> buffer;


uint number_of_points;
uint height;
uint width;
uint trailReduction;

float xmovementCords;
float ymovementCords;


float averager;
float averageg;
float averageb;
float averagea;
uint neighbourCount = 0;

float trailBlurAmt;
float trailDuration;

float deltatime;

uint sensorlength;


[numthreads(128,1,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    // TODO: insert actual code here!
    if (id.x > number_of_points)
    {
        return;
    }   
   
    
    
    xmovementCords = (buffer[id.x].speed * cos(buffer[id.x].Angle));
    ymovementCords = (buffer[id.x].speed * sin(buffer[id.x].Angle));
    
    buffer[id.x].totalposition.x += xmovementCords;
    buffer[id.x].totalposition.y += ymovementCords;
    
    if (buffer[id.x].totalposition.x >= width || buffer[id.x].totalposition.x <= 0)
    {
        buffer[id.x].Angle = 3.141592653596969 - buffer[id.x].Angle;
    }
    else if (buffer[id.x].totalposition.y >= height || buffer[id.x].totalposition.y <= 0)
    {
        buffer[id.x].Angle = 2 * 3.141592653596969 - buffer[id.x].Angle;
    }
    Result[buffer[id.x].totalposition] = float4(1, 1, 1, 1);
    
    
    
        float left_sensor_x_coords = (sensorlength * cos(buffer[id.x].Angle + ((0.5) * 3.14159)));
        float left_sensor_y_coords = (sensorlength * sin(buffer[id.x].Angle + ((0.5) * 3.14159)));
    
        float4 left_sensor_value = Result[float2(buffer[id.x].totalposition.x + left_sensor_x_coords, buffer[id.x].totalposition.y + left_sensor_y_coords)];
    
        float right_sensor_x_coords = (sensorlength * cos(buffer[id.x].Angle - ((0.5) * 3.14159)));
        float right_sensor_y_coords = (sensorlength * sin(buffer[id.x].Angle - ((0.5) * 3.14159)));
    
        float4 right_sensor_value = Result[float2(buffer[id.x].totalposition.x + right_sensor_x_coords, buffer[id.x].totalposition.y + right_sensor_y_coords)];
    
   // Result[float2(buffer[id.x].totalposition.x + left_sensor_x_coords, buffer[id.x].totalposition.y + left_sensor_y_coords)] = float4(1, 0, 0, 0);
   // Result[float2(buffer[id.x].totalposition.x + right_sensor_x_coords, buffer[id.x].totalposition.y + right_sensor_y_coords)] = float4(0, 1, 0, 0);
    
    
    
        if (left_sensor_value.r > right_sensor_value.r)
        {
            //Result[float2(buffer[id.x].totalposition.x + left_sensor_x_coords, buffer[id.x].totalposition.y + left_sensor_y_coords)] = float4(0, 1, 0, 0);
            //Result[float2(buffer[id.x].totalposition.x + right_sensor_x_coords, buffer[id.x].totalposition.y + right_sensor_y_coords)] = float4(1, 0, 0, 0);
        
            buffer[id.x].Angle = buffer[id.x].Angle + (0.01 * 3.14159);
        }
        else if (left_sensor_value.r < right_sensor_value.r)
        {
            //Result[float2(buffer[id.x].totalposition.x + left_sensor_x_coords, buffer[id.x].totalposition.y + left_sensor_y_coords)] = float4(1, 0, 0, 0);
            //Result[float2(buffer[id.x].totalposition.x + right_sensor_x_coords, buffer[id.x].totalposition.y + right_sensor_y_coords)] = float4(0, 1, 0, 0);
            buffer[id.x].Angle = buffer[id.x].Angle - (0.01 * 3.14159);
        }
    }


[numthreads(8, 8, 1)]
void Trails(uint3 id : SV_DispatchThreadID)
{
    Result[id.xy] = max(0, Result[id.xy] - trailBlurAmt);
    
    // get rid of the edges
    if (id.x <= 1 || id.x >= width || id.y <= 1 || id.y >= height)
    {
        Result[id.xy] -= deltatime * 2;
        return;
    }
    
    float4 originalValue = Result[id.xy];
    float4 average = (0, 0, 0, 0);
    int neighbourCount;
    
    for (int x = -1; x <= 1; x++)
    {
        for (int y = -1; y <= 1; y++)
        {
            average.r += Result[float2(id.x + x, id.y + y)].r;
            average.g += Result[float2(id.x + x, id.y + y)].g;
            average.b += Result[float2(id.x + x, id.y + y)].b;
            average.a += Result[float2(id.x + x, id.y + y)].a;

            neighbourCount++;
        }
    }
    
    average = average / neighbourCount;
    
    float4 blurResults = lerp(originalValue, float4(average.r, average.g, average.b, 1), trailBlurAmt);
    
    Result[id.xy] = blurResults;
}
